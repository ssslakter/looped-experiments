# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03.1_curriculum.ipynb.

# %% auto 0
__all__ = ['linear_clm', 'log_clm', 'sqrt_clm', 'cos_clm', 'Curriculum', 'CurriculumCB', 'LoopCB']

# %% ../nbs/03.1_curriculum.ipynb 1
import math
from functools import partial
from types import SimpleNamespace

import matplotlib.pyplot as plt
import torch

from .training import Callback

# %% ../nbs/03.1_curriculum.ipynb 5
def linear_clm(cfg, steps):
    return torch.minimum(torch.tensor(cfg.end), cfg.start + steps // cfg.interval * cfg.inc)


def log_clm(cfg, steps, base=1.1):
    values = torch.zeros_like(steps)
    bins=torch.cat((torch.tensor([float("-inf")]),torch.arange(cfg.end - cfg.start)))
    for i, v in enumerate(cfg.interval*torch.cumsum(torch.pow(base, bins), 0)):
        values[steps >= v]= i*cfg.inc
    return torch.minimum(values+cfg.start, torch.tensor(cfg.end))


def sqrt_clm(cfg, steps):
    return torch.round((cfg.end - cfg.start) * torch.sqrt(steps / len(steps)) + cfg.start)


def cos_clm(cfg, steps):
    return torch.round((cfg.end - cfg.start)/2 * -torch.cos(steps / cfg.interval * cfg.inc) + (cfg.end + cfg.start)/2)


# %% ../nbs/03.1_curriculum.ipynb 6
class Curriculum:
    """Curriculum for training"""
    funcs = {
            'linear': linear_clm,
            'log': log_clm,
            'sqrt': sqrt_clm,
            'cos': cos_clm
            }
    
    def __init__(self, cfg, n_steps=10_000, clm_type='linear', clm_func=None, **kwargs):
        """Initialize the Curriculum class.

        Args:
            cfg (dict): The configuration for the curriculum.
            n_steps (int, optional): The total number of steps. Defaults to 10_000.
            clm_type (str, optional): The type of curriculum function. Used if `clm_func` is None. Defaults to 'linear'.
            clm_func (function, optional): The custom curriculum function. Defaults to None.
        """
        self.steps = torch.arange(0, n_steps, 1)
        f = clm_func or self.clm_func(clm_type)
        self.values = f(cfg, self.steps, **kwargs).type(torch.int32)
        

    @classmethod
    def clm_func(self, type: str):
        """Get the curriculum function based on the type."""
        return self.funcs[type]

    def __call__(self, step):
        return self.values[step-1].item()

    def show(self, ax=None, figsize=(12, 5)):
        if ax is None: _, ax = plt.subplots(figsize=figsize)
        ax.plot(self.steps, self.values)
        ax.grid()
        ax.set_xlabel('Steps'), ax.set_ylabel('Value')

# %% ../nbs/03.1_curriculum.ipynb 8
class CurriculumCB(Callback):
    def __init__(self, curriculum_config, train_config):
        self.cfg = curriculum_config
        kwgs = lambda x: ({} if not hasattr(x, 'kwargs') else x.kwargs)
        self.curs = {k: Curriculum(v, n_steps=train_config.train_steps * train_config.n_epoch, clm_type=v.type, **kwgs(v))
                     for k, v in curriculum_config.items()}

    def update_task(self, learn, ds):
        ds.task.n_points = self.curs['points'](learn.train_step)
        n_dims = self.curs['dims'](learn.train_step)
        ds.task.truncated_dims = ds.task.n_dims - n_dims
        if hasattr(learn, 'stats'):
            learn.stats['n_points'] = ds.task.n_points
            learn.stats['n_dims'] = n_dims

    def after_batch(self, learn):
        if learn.model.training: self.update_task(learn, learn.dl_train.dataset)
        else: self.update_task(learn, learn.dl_valid.dataset)


class LoopCB(CurriculumCB):
    def update_model(self, learn):
        learn.model.n_loops = self.curs['loops'](learn.train_step)
        if hasattr(learn, 'stats'):
            learn.stats['n_loops'] = learn.model.n_loops

    def after_batch(self, learn): self.update_model(learn)
